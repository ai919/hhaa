<?php

namespace Utils;

use Typecho\Common;

/**
 * Password hashing utilities based on PHP's password_* functions.
 * Provides compatibility helpers for legacy hashes generated by
 * Typecho's previous PasswordHash implementation and older
 * Common::hash based hashes.
 */
class PasswordHash
{
    public function __construct(int $iteration_count_log2 = 8, bool $portable_hashes = true)
    {
        // parameters kept for backward compatibility - no action required
    }

    /**
     * Hash the given password using PASSWORD_BCRYPT.
     */
    public function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT);
    }

    /**
     * Verify a password against the supplied hash. Supports legacy hashes
     * generated by the old phpass library and Typecho's Common::hash scheme.
     */
    public function checkPassword(string $password, string $stored_hash): bool
    {
        $info = password_get_info($stored_hash);
        if ($info['algo']) {
            return password_verify($password, $stored_hash);
        }

        if (0 === strpos($stored_hash, '$P$')) {
            return self::legacyCheckPassword($password, $stored_hash);
        }

        return Common::hashValidate($password, $stored_hash);
    }

    /**
     * Determine whether the supplied hash needs to be rehashed using the
     * current algorithm and options.
     */
    public function needsRehash(string $hash): bool
    {
        $info = password_get_info($hash);
        if ($info['algo']) {
            return password_needs_rehash($hash, PASSWORD_BCRYPT);
        }

        // non password_hash hashes are always considered needing a rehash
        return true;
    }

    /**
     * Verify legacy phpass hashes prefixed with "$P$".
     */
    private static function legacyCheckPassword(string $password, string $hash): bool
    {
        $itoa64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        $count_log2 = strpos($itoa64, $hash[3]);
        if ($count_log2 < 7 || $count_log2 > 30) {
            return false;
        }
        $count = 1 << $count_log2;
        $salt = substr($hash, 4, 8);
        if (strlen($salt) != 8) {
            return false;
        }
        $tmp = md5($salt . $password, true);
        do {
            $tmp = md5($tmp . $password, true);
        } while (--$count);

        $output = substr($hash, 0, 12);
        $output .= self::legacyEncode64($tmp, 16, $itoa64);

        return hash_equals($hash, $output);
    }

    /**
     * Encoding helper used by legacy phpass hashes.
     */
    private static function legacyEncode64(string $input, int $count, string $itoa64): string
    {
        $output = '';
        $i = 0;
        do {
            $value = ord($input[$i++]);
            $output .= $itoa64[$value & 0x3f];
            if ($i < $count) {
                $value |= ord($input[$i]) << 8;
            }
            $output .= $itoa64[($value >> 6) & 0x3f];
            if ($i++ >= $count) {
                break;
            }
            if ($i < $count) {
                $value |= ord($input[$i]) << 16;
            }
            $output .= $itoa64[($value >> 12) & 0x3f];
            if ($i++ >= $count) {
                break;
            }
            $output .= $itoa64[($value >> 18) & 0x3f];
        } while ($i < $count);

        return $output;
    }
}

